#include "font.h"
#include <xtl.h>

// This matches the VERTEX layout used in renderer, but is local to this TU.
struct VERTEX
{
    float x, y, z, rhw;
    DWORD color;
};

// Use the D3D device defined in renderer.cpp / main.cpp
extern LPDIRECT3DDEVICE8 g_pDevice;

// 5x7 bitmap font data and renderer

struct Glyph
{
    char           ch;
    unsigned char  r[7];
};

// NOTE:
//  - a–z are mapped to A–Z in FindGlyph() so we only store uppercase.
//  - Unknown characters fall back to space.
//  - This is a tweaked “Option B” style: slightly more geometric/sci-fi,
//    but still 5x7 and compatible with the rest of the project.

static Glyph g_font[] =
{
    // Space
    { ' ',{0x00,0x00,0x00,0x00,0x00,0x00,0x00} },

    // A–Z (updated shapes)
    { 'A',{0x0E,0x11,0x11,0x1F,0x11,0x11,0x11} }, // A
    { 'B',{0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E} }, // B
    { 'C',{0x0E,0x11,0x10,0x10,0x10,0x11,0x0E} }, // C
    { 'D',{0x1E,0x11,0x11,0x11,0x11,0x11,0x1E} }, // D (more rounded)
    { 'E',{0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F} }, // E
    { 'F',{0x1F,0x10,0x10,0x1E,0x10,0x10,0x10} }, // F
    { 'G',{0x0E,0x11,0x10,0x17,0x11,0x11,0x0F} }, // G (open mouth)
    { 'H',{0x11,0x11,0x11,0x1F,0x11,0x11,0x11} }, // H
    { 'I',{0x1F,0x04,0x04,0x04,0x04,0x04,0x1F} }, // I (framed)
    { 'J',{0x07,0x02,0x02,0x02,0x12,0x12,0x0C} }, // J (more sci-fi)
    { 'K',{0x11,0x12,0x14,0x18,0x14,0x12,0x11} }, // K
    { 'L',{0x10,0x10,0x10,0x10,0x10,0x10,0x1F} }, // L
    { 'M',{0x11,0x1B,0x15,0x11,0x11,0x11,0x11} }, // M
    { 'N',{0x11,0x19,0x15,0x13,0x11,0x11,0x11} }, // N
    { 'O',{0x0E,0x11,0x11,0x11,0x11,0x11,0x0E} }, // O
    { 'P',{0x1E,0x11,0x11,0x1E,0x10,0x10,0x10} }, // P
    { 'Q',{0x0E,0x11,0x11,0x11,0x15,0x12,0x0D} }, // Q (tail)
    { 'R',{0x1E,0x11,0x11,0x1E,0x14,0x12,0x11} }, // R
    { 'S',{0x0F,0x10,0x10,0x0E,0x01,0x01,0x1E} }, // S
    { 'T',{0x1F,0x04,0x04,0x04,0x04,0x04,0x04} }, // T
    { 'U',{0x11,0x11,0x11,0x11,0x11,0x11,0x0E} }, // U
    { 'V',{0x11,0x11,0x11,0x11,0x0A,0x0A,0x04} }, // V (tighter bottom)
    { 'W',{0x11,0x11,0x11,0x15,0x15,0x1B,0x11} }, // W (chunkier mid)
    { 'X',{0x11,0x11,0x0A,0x04,0x0A,0x11,0x11} }, // X
    { 'Y',{0x11,0x11,0x0A,0x04,0x04,0x04,0x04} }, // Y
    { 'Z',{0x1F,0x01,0x02,0x04,0x08,0x10,0x1F} }, // Z

    // Digits (cleaned up a bit)
    { '0',{0x0E,0x11,0x13,0x15,0x19,0x11,0x0E} }, // 0
    { '1',{0x04,0x0C,0x14,0x04,0x04,0x04,0x1F} }, // 1
    { '2',{0x0E,0x11,0x01,0x02,0x04,0x08,0x1F} }, // 2
    { '3',{0x0E,0x11,0x01,0x06,0x01,0x11,0x0E} }, // 3
    { '4',{0x02,0x06,0x0A,0x12,0x1F,0x02,0x02} }, // 4
    { '5',{0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E} }, // 5
    { '6',{0x06,0x08,0x10,0x1E,0x11,0x11,0x0E} }, // 6
    { '7',{0x1F,0x01,0x02,0x04,0x08,0x08,0x08} }, // 7
    { '8',{0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E} }, // 8
    { '9',{0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C} }, // 9

    // Core punctuation (mostly unchanged, already readable)
    { ':',{0x00,0x04,0x04,0x00,0x04,0x04,0x00} },
    { '.',{0x00,0x00,0x00,0x00,0x00,0x06,0x06} },
    { ',',{0x00,0x00,0x00,0x00,0x06,0x06,0x02} },
    { ';',{0x00,0x04,0x00,0x00,0x04,0x04,0x02} },
    { '!',{0x04,0x04,0x04,0x04,0x04,0x00,0x04} },
    { '?',{0x0E,0x11,0x01,0x02,0x04,0x00,0x04} },

    // Math / separators
    { '-',{0x00,0x00,0x00,0x0E,0x00,0x00,0x00} },
    { '_',{0x00,0x00,0x00,0x00,0x00,0x00,0x1F} },
    { '+',{0x00,0x04,0x04,0x1F,0x04,0x04,0x00} },
    { '=',{0x00,0x1F,0x00,0x1F,0x00,0x00,0x00} },
    { '/',{0x01,0x01,0x02,0x04,0x08,0x10,0x10} },
    { '\\',{0x10,0x10,0x08,0x04,0x02,0x01,0x01} },

    // Brackets / grouping
    { '(',{0x02,0x04,0x08,0x08,0x08,0x04,0x02} },
    { ')',{0x08,0x04,0x02,0x02,0x02,0x04,0x08} },
    { '[',{0x0E,0x08,0x08,0x08,0x08,0x08,0x0E} },
    { ']',{0x0E,0x02,0x02,0x02,0x02,0x02,0x0E} },

    // Quotes
    { '\'',{0x04,0x04,0x04,0x00,0x00,0x00,0x00} },
    { '"',{0x0A,0x0A,0x0A,0x00,0x00,0x00,0x00} },

    // Symbols
    { '#',{0x0A,0x0A,0x1F,0x0A,0x1F,0x0A,0x0A} },
    { '%',{0x18,0x19,0x02,0x04,0x08,0x13,0x03} },
    { '@',{0x0E,0x11,0x17,0x15,0x17,0x10,0x0E} },
    { '<',{0x02,0x04,0x08,0x10,0x08,0x04,0x02} },
    { '>',{0x08,0x04,0x02,0x01,0x02,0x04,0x08} },
};

static const int g_fontCount = sizeof(g_font) / sizeof(g_font[0]);

// -----------------------------------------------------------------------------
// Glyph lookup
// -----------------------------------------------------------------------------
static const Glyph* FindGlyph(char c)
{
    // Force lowercase into uppercase
    if (c >= 'a' && c <= 'z')
        c = char(c - 'a' + 'A');

    for (int i = 0; i < g_fontCount; ++i)
    {
        if (g_font[i].ch == c)
            return &g_font[i];
    }
    // default to space
    return &g_font[0];
}

// -----------------------------------------------------------------------------
// Low-level “raw” char draw: single pass, no effects
// -----------------------------------------------------------------------------
static void DrawCharRaw(float x, float y, char c, float scale, DWORD color)
{
    const Glyph* g = FindGlyph(c);
    float pw = scale;
    float ph = scale;

    for (int row = 0; row < 7; ++row)
    {
        unsigned char bits = g->r[row];
        for (int col = 0; col < 5; ++col)
        {
            int bitIndex = 4 - col;
            if ((bits >> bitIndex) & 1)
            {
                float px = x + col * pw;
                float py = y + row * ph;

                VERTEX v[4] =
                {
                    { px,      py,      0.0f, 1.0f, color },
                    { px + pw, py,      0.0f, 1.0f, color },
                    { px,      py + ph, 0.0f, 1.0f, color },
                    { px + pw, py + ph, 0.0f, 1.0f, color }
                };

                g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, v, sizeof(VERTEX));
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Stylized char: simple drop-shadow + main glyph
// -----------------------------------------------------------------------------
static void DrawChar(float x, float y, char c, float scale, DWORD color)
{
    // Slight offset for the shadow (scaled so it looks good at any size)
    float off = scale * 0.9f;
    DWORD shadowColor = D3DCOLOR_XRGB(0, 0, 0);

    // Shadow pass (behind, down-right)
    DrawCharRaw(x + off, y + off, c, scale, shadowColor);

    // Main pass
    DrawCharRaw(x, y, c, scale, color);
}

// -----------------------------------------------------------------------------
// Public text draw
// -----------------------------------------------------------------------------
void DrawText(float x, float y, const char* text, float scale, DWORD color)
{
    float cx = x;
    const float advance = 6.0f * scale; // 5px glyph + 1px gap

    while (*text)
    {
        DrawChar(cx, y, *text, scale, color);
        cx += advance;
        ++text;
    }
}
